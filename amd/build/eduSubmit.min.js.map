{"version":3,"file":"eduSubmit.min.js","sources":["../src/eduSubmit.js"],"sourcesContent":["// This file is part of Moodle - https://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * Script eduSubmit.js\n *\n * @module      tiny_edusharing/eduSubmit\n * @copyright   2024 metaVentis GmbH <http://metaventis.com>\n * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n *\n * This script contains all logic to be executed when the user saves the changes they made in the editor\n * by clicking the \"save changes\" button.\n * It also contains the logic for keeping score of es elements already present in the section opened.\n */\n\nimport {getCourseId, getRepoId} from \"./options\";\nimport {addEduSharingInstance, deleteEduSharingInstance, updateInstance} from \"./repository\";\nimport {get_string as getString} from 'core/str';\nimport Config from 'core/config';\nimport Modal from 'core/modal';\nimport {component} from './common';\nimport {renderForPromise} from 'core/templates';\n\nconst formEditorsMap = new WeakMap();\n\n// Per-editor initial elements.\nconst initialElementsMap = new WeakMap();\n\nexport const initEventHandler = (editor) => {\n    const container = editor.getContainer();\n    const form = container.closest(\"form\");\n    if (form !== null && typeof form.submit === \"function\") {\n        let editors = formEditorsMap.get(form);\n        if (!editors) {\n            editors = new Set();\n            formEditorsMap.set(form, editors);\n        }\n        editors.add(editor);\n\n        if (!form.dataset.esSubmitHook) {\n            form.dataset.esSubmitHook = \"1\";\n            form.addEventListener('submit', async(event) => {\n                if (form.dataset.esBypassSubmit === \"1\") {\n                    delete form.dataset.esBypassSubmit;\n                    return;\n                }\n                const submitter = event.submitter;\n                if (!submitter || (submitter.id !== \"id_submitbutton\" && submitter.id !== \"id_submitbutton2\")) {\n                    return;\n                }\n                event.preventDefault();\n\n                const formEditors = formEditorsMap.get(form) || new Set();\n                try {\n                    await Promise.all([...formEditors].map(editor => convertForSubmit(editor)));\n                } finally {\n                    form.dataset.esBypassSubmit = \"1\";\n                    if (submitter.id === \"id_submitbutton\") {\n                        const hidden = document.createElement('input');\n                        hidden.type = 'hidden';\n                        hidden.name = 'submitbutton';\n                        hidden.value = '1';\n                        form.appendChild(hidden);\n                    }\n                    form.submit();\n                }\n            });\n        }\n    }\n};\n\nconst convertForSubmit = async(editor) => {\n    const initialElements = initialElementsMap.get(editor) || [];\n    let showIframeRemovalDialog = false;\n    let removedWidgets = [];\n    /**\n     * Recursively processes a DOM node and its children to handle specific cases related to\n     * ES embedding in various elements such as images, links, iframes, and text nodes. This function\n     * applies different processing strategies based on the type and attributes of each element encountered.\n     *\n     * @async\n     * @function iterateAsync\n     * @param {Node} domNode - The root DOM node to start the processing from. The function will recursively\n     *                         process all child nodes and handle specific cases based on node type and attributes.\n     * @returns {Promise<void>} A promise that resolves when all nodes in the subtree have been processed.\n     */\n\n    const iterateAsync = async domNode => {\n        /**\n         * Processes an added or edited ES DOM element. The function determines whether the element is new or updated\n         * based on its attributes and performs the required backend operations via AJAX calls. If the element is updated,\n         * it sends an update request. If the element is new, it sends a creation request and updates the DOM accordingly.\n         *\n         * @async\n         * @function\n         * @param {HTMLElement} domNode - The DOM node representing the element to process. This can be an image\n         * or a link element, which contains all necessary attributes for identifying and processing.\n         */\n        const processAddedOrEditedElement = async(domNode) => {\n            let link = domNode.getAttribute(domNode.nodeName.toLowerCase() === 'img' ? 'src' : 'href');\n            let uri = new URL(link);\n            let searchParams = uri.searchParams;\n            let indexOfElement = initialElements.indexOf(parseInt(searchParams.get('resourceId')));\n            if (indexOfElement >= 0) {\n                initialElements.splice(indexOfElement, 1);\n                if (domNode.getAttribute('data-edited') !== null && domNode.getAttribute('data-edited') !== \"\") {\n                    let ajaxParams = {\n                        eduStructure: {\n                            id: parseInt(searchParams.get('resourceId')),\n                            courseId: parseInt(getCourseId(editor)),\n                            objectUrl: searchParams.get('object_url')\n                        }\n                    };\n                    let response = await updateInstance(ajaxParams);\n                    if (response.id === undefined) {\n                        window.console.log('Error updating instance');\n                    }\n                    domNode.removeAttribute('data-edited');\n                }\n            } else {\n                let ajaxParams = {\n                    eduStructure: {\n                        name: searchParams.get('title'),\n                        objectUrl: searchParams.get('object_url'),\n                        courseId: parseInt(getCourseId(editor)),\n                        objectVersion: searchParams.get('window_version')\n                    }\n                };\n                let response = await addEduSharingInstance(ajaxParams);\n                if (response.id !== undefined) {\n                    let isImage = domNode.nodeName.toLowerCase() === 'img';\n                    let previewUrl = `${Config.wwwroot}/mod/edusharing/preview.php`\n                        + '?resourceId=' + response.id + '&' + searchParams.toString();\n                    domNode.setAttribute(isImage ? 'src' : 'href', previewUrl);\n                }\n            }\n        };\n        /**\n         * Processes a DOM text node, replacing or removing ES embedding iFrame elements.\n         *\n         * This function examines the text content of a given DOM node, parses it into a temporary div,\n         * and processes iframe elements that match specific criteria. If the iframe's `data-repo-id` attribute\n         * matches the connected repository, it replaces the iframe with new content or removes it if no replacement is available.\n         * Once processing is complete, it replaces the original DOM node with the updated content.\n         *\n         * @async\n         * @function\n         * @param {Node} domNode - The DOM node containing the text content to be processed.\n         * @returns {Promise<void>} - A promise that resolves when the processing is complete.\n         */\n        const processTextNode = async(domNode) => {\n            const tempDiv = document.createElement('div');\n            tempDiv.innerHTML = domNode.textContent;\n            const iframes = tempDiv.querySelectorAll('iframe.es-embed-iframe');\n            for (const iframe of iframes) {\n                if (iframe.getAttribute('data-repo-id') === getRepoId(editor)) {\n                    const replacement = await getIframeReplacementContent(editor, iframe);\n                    if (replacement !== '') {\n                        iframe.outerHTML = replacement;\n                    } else {\n                        iframe.remove();\n                        showIframeRemovalDialog = true;\n                    }\n                } else {\n                    iframe.remove();\n                    showIframeRemovalDialog = true;\n                }\n            }\n            const widgets = tempDiv.querySelectorAll('edu-sharing-generic-widget');\n            for (const widget of widgets) {\n                try {\n                    const payload = toWidgetPayload(widget);\n                    const replacement = await renderForPromise(`${component}/widget`, {widgetData: payload});\n                    widget.outerHTML = replacement.html;\n                } catch (e) {\n                    widget.remove();\n                    removedWidgets.push(e.message.split(':').pop());\n                }\n            }\n            if (iframes.length > 0 || widgets.length > 0) {\n                domNode.replaceWith(...tempDiv.childNodes);\n            }\n        };\n        /**\n         * Asynchronously processes an iframe DOM node, replacing or removing it based on the replacement content.\n         *\n         * This function takes a DOM node representing an iframe, retrieves its replacement content asynchronously,\n         * and updates the DOM in one of the following ways:\n         * - Replaces the iframe's outer HTML with the retrieved replacement content if the content is not an empty string.\n         * - Removes the iframe from the DOM if the replacement content is an empty string.\n         *\n         * @param {HTMLElement} domNode - The iframe DOM node to be processed.\n         * @returns {Promise<void>} A promise that resolves when the processing is complete.\n         */\n        const processIframe = async(domNode) => {\n            const replacement = await getIframeReplacementContent(editor, domNode);\n            if (replacement !== '') {\n                domNode.outerHTML = replacement;\n            } else {\n                domNode.remove();\n                showIframeRemovalDialog = true;\n            }\n        };\n        /**\n         * Asynchronously processes a widget contained within a DOM node.\n         *\n         * This function performs operations related to the provided DOM node,\n         * enabling interaction or manipulation of the widget represented.\n         *\n         * @async\n         * @param {HTMLElement} domNode - The DOM node containing the widget to process.\n         * @returns {Promise<void>} A promise that resolves when the processing is complete.\n         */\n        const processWidget = async(domNode) => {\n            try {\n                const payload = toWidgetPayload(domNode);\n                const renderedTemplate = await renderForPromise(`${component}/widget`, {\n                    widgetData: payload\n                });\n                domNode.outerHTML = renderedTemplate.html;\n            } catch (e) {\n                domNode.remove();\n                removedWidgets.push(e.message.split(':').pop());\n            }\n        };\n        if (domNode.hasChildNodes()) {\n            for (const node of domNode.childNodes) {\n                await iterateAsync(node);\n            }\n        }\n        if (domNode.classList !== undefined && domNode.classList.contains('edusharing_atto')) {\n            await processAddedOrEditedElement(domNode);\n        }\n        if (domNode.nodeType === Node.TEXT_NODE &&\n            (domNode.textContent.includes('<iframe') || domNode.textContent.includes('generic-widget'))) {\n            await processTextNode(domNode);\n        }\n        if (domNode instanceof HTMLIFrameElement\n            && domNode.classList !== undefined\n            && domNode.classList.contains('es-embed-iframe')) {\n            if (domNode.getAttribute('data-repo-id') === getRepoId(editor)) {\n                await processIframe(domNode);\n            }\n        }\n        if (domNode instanceof Element && domNode.tagName.toLowerCase() === 'edu-sharing-generic-widget') {\n            await processWidget(domNode);\n        }\n    };\n\n    const container = window.document.createElement('div');\n    container.innerHTML = editor.getContent();\n    await iterateAsync(container);\n    editor.setContent(container.innerHTML);\n    for (const resourceId of initialElements) {\n        await deleteEduSharingInstance({\n            eduDeleteStructure: {\n                id: resourceId,\n                courseId: parseInt(getCourseId(editor))\n            }\n        });\n    }\n    if (showIframeRemovalDialog || removedWidgets.length > 0) {\n        const translatedTitle = await new Promise((resolve) => {\n            getString('removalTitle', 'tiny_edusharing').done(resolve);\n        });\n        let translatedIframeMessage = \"\";\n        if (showIframeRemovalDialog) {\n            translatedIframeMessage = await new Promise((resolve) => {\n                getString('iframeRemovalInfo', 'tiny_edusharing').done(resolve);\n            });\n            translatedIframeMessage = '<p>' + translatedIframeMessage + '</p>';\n        }\n        let translatedModalMessage = \"\";\n        if (removedWidgets.length > 0) {\n            translatedModalMessage = await new Promise((resolve) => {\n                getString('widgetRemovalInfo', 'tiny_edusharing').done(resolve);\n            });\n            translatedModalMessage = '<p>' + translatedModalMessage.replace('##placeholder##', removedWidgets.join(', ')) + '</p>';\n        }\n        const body = (showIframeRemovalDialog ? translatedIframeMessage : '')\n            + (removedWidgets.length > 0 ? translatedModalMessage : '');\n        const modal = await Modal.create({\n            title: translatedTitle,\n            body: body,\n            footer: '<button type=\"button\" class=\"btn btn-primary\" data-action=\"confirm\">OK</button>',\n            show: true,\n            removeOnClose: true\n        });\n        await new Promise((resolve) => {\n            modal.getRoot().on('click', '[data-action=\"confirm\"]', resolve);\n            modal.getRoot().on('hidden.bs.modal', resolve);\n        });\n    }\n    initialElementsMap.set(editor, []);\n};\n\n/**\n * Asynchronously retrieves and processes replacement content for an ES embedding iframe, based on its attributes\n * and additional data fetched or computed during the process.\n *\n * @param {object} editor - The editor instance responsible for managing content operations.\n * @param {HTMLElement} domNode - The DOM node representing the iframe for which content replacement is executed.\n * @returns {Promise<string>} A promise that resolves to the HTML content for replacing the iframe,\n * or an empty string if processing fails or required data is unavailable.\n * @throws {Error} If an unexpected issue occurs during processing, resulting in a rejection with an empty string.\n */\nconst getIframeReplacementContent = async(editor, domNode) => {\n    const iframeSrc = domNode.getAttribute('src');\n    try {\n        const url = new URL(iframeSrc);\n        const urlSearchParams = url.searchParams;\n        const nodeId = urlSearchParams.get('node_id');\n        const version = urlSearchParams.get('version') ?? '0';\n        const mimeType = urlSearchParams.get('mimetype');\n        const title = domNode.getAttribute('title');\n        const mediaType = domNode.getAttribute('data-mediatype');\n        const width = domNode.getAttribute('width');\n        const height = domNode.getAttribute('height');\n        const ccrepUrl =\n            'ccrep://' +\n            encodeURIComponent(getRepoId(editor)) +\n            '/' +\n            encodeURIComponent(nodeId);\n        if (nodeId) {\n            const ajaxParams = {\n                eduStructure: {\n                    name: title,\n                    objectUrl: ccrepUrl,\n                    courseId: parseInt(getCourseId(editor)),\n                    objectVersion: version\n                }\n            };\n            const response = await addEduSharingInstance(ajaxParams);\n            if (response.id !== undefined) {\n                let previewUrl = `${Config.wwwroot}/mod/edusharing/preview.php`\n                    + '?resourceId=' + response.id + '&nodeId=' + nodeId + '&mimetype=' + mimeType\n                    + '&mediatype=' + mediaType + '&width=' + width + '&height=' + height;\n                const renderedTemplate = await renderForPromise(`${component}/content`, {\n                    edusharingImg: mediaType !== 'ref',\n                    edusharingRef: mediaType === 'ref',\n                    edusharingPreviewSrc: previewUrl,\n                    edusharingTitle: title.toString(),\n                    edusharingInsertCaption: false,\n                    edusharingCaption: '',\n                    edusharingWidth: width.toString(),\n                    edusharingHeight: height.toString(),\n                    edusharingStyle: '',\n                    dataEdited: false\n                });\n                return renderedTemplate.html;\n            }\n        }\n        return '';\n    } catch (e) {\n        window.console.error(e);\n        return '';\n    }\n};\n\nexport const initExistingElements = editor => {\n    const iterate = domNode => {\n        if (domNode.hasChildNodes()) {\n            for (const node of domNode.childNodes) {\n                iterate(node);\n            }\n        }\n        if (domNode.classList !== undefined && domNode.classList.contains('edusharing_atto')) {\n            let link = domNode.getAttribute(domNode.nodeName.toLowerCase() === 'img' ? 'src' : 'href');\n            let uri = new URL(link);\n            const arr = initialElementsMap.get(editor) || [];\n            arr.push(parseInt(uri.searchParams.get('resourceId')));\n            initialElementsMap.set(editor, arr);\n        }\n    };\n    const container = window.document.createElement('div');\n    container.innerHTML = editor.getContent();\n    iterate(container);\n};\n\n/**\n * Extract a widget payload from a DOM node:\n * - tag: the element tag name (lowercased)\n * - attrs: all attributes as key/value pairs\n * Children/content are intentionally ignored.\n *\n * @param {Element} domNode\n * @returns {string}\n */\nexport const toWidgetPayload = (domNode) => {\n    if (!domNode || domNode.nodeType !== Node.ELEMENT_NODE) {\n        throw new TypeError('toWidgetPayload: domNode must be an Element');\n    }\n\n    const tag = domNode.tagName.toLowerCase();\n    /** @type {Record<string, string|boolean>} */\n    const attrs = {};\n\n    for (const attr of Array.from(domNode.attributes)) {\n        attrs[attr.name] = attr.value === '' ? true : attr.value;\n    }\n    if (attrs['widget-type'] !== 'wlo-content-teaser') {\n        throw new Error(`unsupported:${attrs['widget-type']}`);\n    }\n    return JSON.stringify({tag, attrs});\n};\n"],"names":["formEditorsMap","WeakMap","initialElementsMap","editor","form","getContainer","closest","submit","editors","get","Set","set","add","dataset","esSubmitHook","addEventListener","async","esBypassSubmit","submitter","event","id","preventDefault","formEditors","Promise","all","map","convertForSubmit","hidden","document","createElement","type","name","value","appendChild","initialElements","showIframeRemovalDialog","removedWidgets","iterateAsync","domNode","hasChildNodes","node","childNodes","undefined","classList","contains","link","getAttribute","nodeName","toLowerCase","searchParams","URL","indexOfElement","indexOf","parseInt","splice","ajaxParams","eduStructure","courseId","objectUrl","window","console","log","removeAttribute","objectVersion","response","isImage","previewUrl","Config","wwwroot","toString","setAttribute","processAddedOrEditedElement","nodeType","Node","TEXT_NODE","textContent","includes","tempDiv","innerHTML","iframes","querySelectorAll","iframe","replacement","getIframeReplacementContent","outerHTML","remove","widgets","widget","payload","toWidgetPayload","component","widgetData","html","e","push","message","split","pop","length","replaceWith","processTextNode","HTMLIFrameElement","processIframe","Element","tagName","renderedTemplate","processWidget","container","getContent","setContent","resourceId","eduDeleteStructure","translatedTitle","resolve","done","translatedIframeMessage","translatedModalMessage","replace","join","body","modal","Modal","create","title","footer","show","removeOnClose","getRoot","on","iframeSrc","urlSearchParams","nodeId","version","mimeType","mediaType","width","height","ccrepUrl","encodeURIComponent","edusharingImg","edusharingRef","edusharingPreviewSrc","edusharingTitle","edusharingInsertCaption","edusharingCaption","edusharingWidth","edusharingHeight","edusharingStyle","dataEdited","error","iterate","uri","arr","ELEMENT_NODE","TypeError","tag","attrs","attr","Array","from","attributes","Error","JSON","stringify"],"mappings":"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"}